src/
├── App.tsx
├── components
│   ├── control-buttons.tsx
│   ├── countdown-settings.tsx
│   ├── mode-buttons.tsx
│   ├── progress-indicator.tsx
│   ├── round-display.tsx
│   ├── time-display.tsx
│   ├── time-input.tsx
│   ├── timer-display.tsx
│   └── timer.tsx
├── constants
│   └── timer.ts
├── context
│   ├── timer-context.ts
│   └── timer-provider.tsx
├── hooks
│   ├── use-timer-animation.ts
│   ├── use-timer-context.ts
│   └── use-timer.ts
├── main.tsx
├── models
│   ├── amrap-timer.ts
│   ├── base-timer.ts
│   ├── emom-timer.ts
│   ├── for-time-timer.ts
│   ├── timer-factory.ts
│   └── timer-reducer.ts
├── services
│   ├── audio.service.ts
│   ├── sound-manager.ts
│   ├── sound.service.ts
│   └── timer.service.ts
├── setupTests.ts
├── theme
│   ├── breakpoints.ts
│   └── theme.ts
├── types
│   ├── timer-actions.ts
│   └── timer.ts
└── utils
    └── time.ts

10 directories, 33 files

Содержимое файлов:
==================

--- src/context/timer-provider.tsx ---
import { FC, PropsWithChildren, useMemo, useState } from "react";

import { useTimerAnimation } from "../hooks/use-timer-animation";
import { TimerState } from "../models/base-timer";
import { TimerService } from "../services/timer.service";
import { TimerMode } from "../types/timer";

import { TimerContext } from "./timer-context";

export const TimerProvider: FC<PropsWithChildren> = ({ children }) => {
  const [timerService] = useState(() => new TimerService("forTime"));
  const [state, setState] = useState<TimerState>(timerService.getState());

  useTimerAnimation(timerService, setState);

  const setMode = (mode: TimerMode) => {
    timerService.setMode(mode);
    setState(timerService.getState());
  };

  const startTimer = (targetTime?: number) => {
    timerService.start(targetTime);
    setState(timerService.getState());
  };

  const stopTimer = () => {
    timerService.stop();
    setState(timerService.getState());
  };

  const resetTimer = () => {
    timerService.reset();
    setState(timerService.getState());
  };

  const contextValue = useMemo(
    () => ({
      state,
      currentTimer: timerService.getTimer(),
      setMode,
      startTimer,
      stopTimer,
      resetTimer,
      setState,
    }),
    [state, timerService, setMode, startTimer, stopTimer, resetTimer],
  );

  return <TimerContext.Provider value={contextValue}>{children}</TimerContext.Provider>;
};

TimerProvider.displayName = "TimerProvider";
-----------------

--- src/context/timer-context.ts ---
import { createContext } from "react";

import { TimerContextType } from "../types/timer";

export const TimerContext = createContext<TimerContextType | null>(null);

TimerContext.displayName = "TimerContext";
-----------------

--- src/models/base-timer.ts ---
import { Theme } from "../types/timer";

export interface TimerState {
  startTime: number | null;
  elapsedTime: number;
  isRunning: boolean;
  currentMode: string;
  targetTime: number;
  currentRound: number;
  countdownActive: boolean;
  countdownValue: number;
  countdownDuration: number;
  theme: Theme;
}

export abstract class BaseTimer {
  protected state: TimerState;

  constructor(mode: string) {
    const savedDuration = localStorage.getItem("countdownDuration");
    const countdownDuration = savedDuration ? Math.max(0, parseInt(savedDuration)) : 3000;

    this.state = {
      startTime: null,
      elapsedTime: 0,
      isRunning: false,
      currentMode: mode,
      targetTime: 0,
      currentRound: 1,
      countdownActive: false,
      countdownValue: countdownDuration,
      countdownDuration: countdownDuration,
      theme: "dark",
    };
  }

  abstract update(): void;

  getState(): TimerState {
    return { ...this.state };
  }

  canStart(): boolean {
    return !this.state.isRunning && !this.state.countdownActive;
  }

  start(targetTime?: number): void {
    const now = Date.now();

    if (this.state.countdownDuration > 0) {
      this.state = {
        ...this.state,
        countdownActive: true,
        countdownValue: this.state.countdownDuration,
        targetTime: targetTime !== undefined ? Math.max(0, targetTime) : this.state.targetTime,
        startTime: now,
      };
    } else {
      this.state = {
        ...this.state,
        startTime: now,
        targetTime: targetTime !== undefined ? Math.max(0, targetTime) : this.state.targetTime,
        isRunning: true,
      };
    }
  }

  stop(): void {
    if (!this.state.startTime) {
      return;
    }

    const now = Date.now();
    const elapsed = Math.min(now - this.state.startTime, Number.MAX_SAFE_INTEGER);

    this.state = {
      ...this.state,
      isRunning: false,
      startTime: null,
      countdownActive: false,
      elapsedTime: this.state.elapsedTime + elapsed,
    };
  }

  reset(): void {
    this.state = {
      ...this.state,
      startTime: null,
      elapsedTime: 0,
      isRunning: false,
      currentRound: 1,
      countdownActive: false,
      countdownValue: this.state.countdownDuration,
      targetTime: 0,
    };
  }

  setCountdownDuration(duration: number): void {
    if (this.state.isRunning || this.state.countdownActive) {
      return;
    }

    if (duration < 0) {
      return;
    }

    localStorage.setItem("countdownDuration", duration.toString());

    this.state = {
      ...this.state,
      countdownDuration: duration,
      countdownValue: duration,
    };
  }

  setTargetTime(time: number): void {
    if (this.state.isRunning || this.state.countdownActive) {
      return;
    }

    if (time < 0) {
      return;
    }

    this.state = {
      ...this.state,
      targetTime: time,
    };
  }

  protected updateElapsedTime(): void {
    if (!this.state.startTime) {
      return;
    }

    const now = Date.now();
    const maxTime = Number.MAX_SAFE_INTEGER;

    if (this.state.countdownActive) {
      const elapsed = Math.min(now - this.state.startTime, maxTime);
      const countdownValue = Math.max(0, this.state.countdownDuration - elapsed);

      if (countdownValue === 0) {
        this.state = {
          ...this.state,
          countdownActive: false,
          isRunning: true,
          startTime: now,
        };
      } else {
        this.state = {
          ...this.state,
          countdownValue,
        };
      }
    } else if (this.state.isRunning) {
      const elapsed = Math.min(now - this.state.startTime, maxTime);

      this.state = {
        ...this.state,
        elapsedTime: this.state.elapsedTime + elapsed,
        startTime: now,
      };
    }
  }
}
-----------------

--- src/models/amrap-timer.ts ---
import { BaseTimer } from "./base-timer";

export class AmrapTimer extends BaseTimer {
  constructor() {
    super("amrap");
  }

  update(): void {
    if (!this.state.isRunning && !this.state.countdownActive) {
      return;
    }

    this.updateElapsedTime();

    if (
      this.state.isRunning &&
      this.state.targetTime > 0 &&
      this.state.elapsedTime >= this.state.targetTime
    ) {
      this.stop();
    }
  }

  getDisplayTime(): number {
    if (this.state.countdownActive) {
      return this.state.countdownValue;
    }

    return Math.max(0, this.state.targetTime - this.state.elapsedTime);
  }

  start(targetTime?: number): void {
    if (!targetTime) {
      return;
    }

    super.start(targetTime);
  }
}
-----------------

--- src/models/timer-factory.ts ---
import { TimerMode } from "../types/timer";

import { AmrapTimer } from "./amrap-timer";
import { BaseTimer } from "./base-timer";
import { EmomTimer } from "./emom-timer";
import { ForTimeTimer } from "./for-time-timer";

const TIMER_MODE_KEY = "timerMode";

export class TimerFactory {
  static createTimer(mode: TimerMode): BaseTimer {
    localStorage.setItem(TIMER_MODE_KEY, mode);

    switch (mode) {
      case "forTime": {
        return new ForTimeTimer();
      }

      case "amrap": {
        return new AmrapTimer();
      }

      case "emom": {
        return new EmomTimer();
      }

      default: {
        throw new Error(`Unknown timer mode: ${mode}`);
      }
    }
  }

  static getLastMode(): TimerMode {
    return (localStorage.getItem(TIMER_MODE_KEY) as TimerMode) || "forTime";
  }
}
-----------------

--- src/models/emom-timer.ts ---
import { TIME, TIMER_CONSTANTS } from "../constants/timer";

import { BaseTimer } from "./base-timer";

export class EmomTimer extends BaseTimer {
  constructor() {
    super("emom");
  }

  update(): void {
    if (!this.state.isRunning && !this.state.countdownActive) {
      return;
    }

    this.updateElapsedTime();

    if (!this.state.countdownActive) {
      this.updateRound();
    }

    if (
      this.state.isRunning &&
      this.state.targetTime > 0 &&
      this.state.elapsedTime >= this.state.targetTime
    ) {
      this.stop();
    }
  }

  getDisplayTime(): number {
    if (this.state.countdownActive) {
      return this.state.countdownValue;
    }

    return this.state.elapsedTime % TIME.MILLISECONDS_IN_MINUTE;
  }

  private updateRound(): void {
    const currentMinute = Math.floor(this.state.elapsedTime / TIME.MILLISECONDS_IN_MINUTE);
    const newRound = currentMinute + 1;

    if (newRound !== this.state.currentRound) {
      this.state.currentRound = newRound;
    }
  }

  start(targetTime?: number): void {
    if (!targetTime) {
      return;
    }

    super.start(targetTime);
  }

  isLastTenSeconds(): boolean {
    const timeInMinute = this.state.elapsedTime % TIME.MILLISECONDS_IN_MINUTE;

    return timeInMinute >= TIMER_CONSTANTS.EMOM_WARNING_TIME;
  }

  isLastFiveSeconds(): boolean {
    const timeInMinute = this.state.elapsedTime % TIME.MILLISECONDS_IN_MINUTE;

    return timeInMinute >= TIMER_CONSTANTS.EMOM_DANGER_TIME;
  }
}
-----------------

--- src/models/timer-reducer.ts ---
import { TimerAction } from "../types/timer-actions";

import { BaseTimer } from "./base-timer";

export const timerReducer = (timer: BaseTimer, action: TimerAction): void => {
  switch (action.type) {
    case "START_TIMER": {
      timer.start(action.targetTime);
      break;
    }

    case "STOP_TIMER": {
      timer.stop();
      break;
    }

    case "RESET_TIMER": {
      timer.reset();
      break;
    }

    case "SET_COUNTDOWN_DURATION": {
      timer.setCountdownDuration(action.duration);
      break;
    }
  }
};
-----------------

--- src/models/for-time-timer.ts ---
import { BaseTimer } from "./base-timer";

export class ForTimeTimer extends BaseTimer {
  constructor() {
    super("forTime");
  }

  update(): void {
    if (!this.state.isRunning && !this.state.countdownActive) {
      return;
    }

    this.updateElapsedTime();
  }

  getDisplayTime(): number {
    return this.state.elapsedTime;
  }
}
-----------------

--- src/hooks/use-timer-animation.ts ---
import { useEffect } from "react";

import { TimerState } from "../models/base-timer";
import { TimerService } from "../services/timer.service";

export const useTimerAnimation = (
  timerService: TimerService,
  setState: (state: TimerState) => void,
) => {
  const animate = () => {
    timerService.update();
    setState(timerService.getState());
    requestAnimationFrame(animate);
  };

  useEffect(() => {
    let frameId: number;
    const currentState = timerService.getState();

    if (currentState.isRunning || currentState.countdownActive) {
      frameId = requestAnimationFrame(animate);
    }

    return () => {
      if (frameId) {
        cancelAnimationFrame(frameId);
      }
    };
  }, [timerService, animate]);
};
-----------------

--- src/hooks/use-timer.ts ---
import { useCallback } from "react";

import { TimerMode } from "../types/timer";

import { useTimerContext } from "./use-timer-context";

export const useTimer = () => {
  const { state, currentTimer, setMode, startTimer, stopTimer, resetTimer } = useTimerContext();

  const handleSetMode = useCallback(
    (mode: TimerMode) => {
      setMode(mode);
    },
    [setMode],
  );

  const handleStartTimer = useCallback(
    (targetTime?: number) => {
      startTimer(targetTime);
    },
    [startTimer],
  );

  const handleStopTimer = useCallback(stopTimer, [stopTimer]);
  const handleResetTimer = useCallback(resetTimer, [resetTimer]);

  return {
    state,
    currentTimer,
    setMode: handleSetMode,
    startTimer: handleStartTimer,
    stopTimer: handleStopTimer,
    resetTimer: handleResetTimer,
  };
};
-----------------

--- src/hooks/use-timer-context.ts ---
import { useContext } from "react";

import { TimerContext } from "../context/timer-context";
import { TimerContextType } from "../types/timer";

export const useTimerContext = (): TimerContextType => {
  const context = useContext(TimerContext);

  if (!context) {
    throw new Error("useTimerContext must be used within a TimerProvider");
  }

  return context;
};
-----------------

--- src/types/timer-actions.ts ---
import { TimerMode } from "./timer";

export type StartTimerAction = {
  type: "START_TIMER";
  targetTime?: number;
};

export type StopTimerAction = {
  type: "STOP_TIMER";
};

export type ResetTimerAction = {
  type: "RESET_TIMER";
};

export type SetModeAction = {
  type: "SET_MODE";
  mode: TimerMode;
};

export type SetCountdownDurationAction = {
  type: "SET_COUNTDOWN_DURATION";
  duration: number;
};

export type TimerAction =
  | StartTimerAction
  | StopTimerAction
  | ResetTimerAction
  | SetModeAction
  | SetCountdownDurationAction;
-----------------

--- src/types/timer.ts ---
import { BaseTimer, TimerState } from "../models/base-timer";

export type TimerMode = "forTime" | "amrap" | "emom";
export type Theme = "light" | "dark";

export interface TimerContextType {
  state: TimerState;
  currentTimer: BaseTimer;
  setMode: (mode: TimerMode) => void;
  startTimer: (targetTime?: number) => void;
  stopTimer: () => void;
  resetTimer: () => void;
  setState: (state: TimerState) => void;
}

export interface SoundState {
  isEnabled: boolean;
  volume: number;
}

export interface TimerSettings {
  sound: SoundState;
  vibration: boolean;
  notifications: boolean;
}
-----------------

--- src/components/mode-buttons.tsx ---
import { Button, ButtonGroup, Tooltip } from "@mui/material";
import { FC, memo, useCallback } from "react";

import { useTimerContext } from "../hooks/use-timer-context";
import { TimerMode } from "../types/timer";

const modeDescriptions: Record<TimerMode, string> = {
  forTime: "Complete the workout as fast as possible",
  amrap: "Complete As Many Rounds As Possible in a set time",
  emom: "Every Minute On the Minute - perform the workout at the start of each minute",
};

export const ModeButtons: FC = memo(() => {
  const { state, setMode } = useTimerContext();

  const handleModeChange = useCallback(
    (mode: TimerMode) => {
      setMode(mode);
    },
    [setMode],
  );

  return (
    <ButtonGroup
      disableElevation
      color='primary'
      orientation='horizontal'
      variant='contained'
      sx={{
        width: "100%",
        "& .MuiButton-root": {
          width: "100%",
          borderRight: "none",
        },
        "& .MuiButtonGroup-grouped:not(:last-of-type)": {
          borderRight: "none",
        },
      }}
    >
      {(Object.keys(modeDescriptions) as TimerMode[]).map((mode) => (
        <Tooltip key={mode} arrow placement='top' title={modeDescriptions[mode]}>
          <Button
            color={state.currentMode === mode ? "primary" : "inherit"}
            disabled={state.isRunning || state.countdownActive}
            variant='contained'
            onClick={() => handleModeChange(mode)}
          >
            {mode.toUpperCase()}
          </Button>
        </Tooltip>
      ))}
    </ButtonGroup>
  );
});

ModeButtons.displayName = "ModeButtons";
-----------------

--- src/components/timer.tsx ---
import { Box, Container } from "@mui/material";
import { FC, memo } from "react";

import { ControlButtons } from "./control-buttons";
import { CountdownSettings } from "./countdown-settings";
import { ModeButtons } from "./mode-buttons";
import { ProgressIndicator } from "./progress-indicator";
import { TimeDisplay } from "./time-display";
import { TimeInput } from "./time-input";

export const Timer: FC = memo(() => {
  return (
    <Box
      sx={{
        backgroundColor: "background.default",
        minHeight: "100vh",
        position: "relative",
      }}
    >
      <Container
        maxWidth='xs'
        sx={{
          height: "100vh",
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          px: 4,
        }}
      >
        <Box
          sx={{
            display: "flex",
            flexDirection: "column",
            alignItems: "center",
            gap: 4,
            width: "100%",
          }}
        >
          <ModeButtons />
          <TimeDisplay />
          <TimeInput />
          <ControlButtons />
          <ProgressIndicator />
          <CountdownSettings />
        </Box>
      </Container>
    </Box>
  );
});

Timer.displayName = "Timer";
-----------------

--- src/components/round-display.tsx ---
import { Theme, Typography, useMediaQuery } from "@mui/material";
import { FC, memo } from "react";

import { useTimerContext } from "../hooks/use-timer-context";

export const RoundDisplay: FC = memo(() => {
  const isMobile = useMediaQuery((theme: Theme) => theme.breakpoints.down("sm"));
  const { state } = useTimerContext();

  if (state.currentMode !== "emom") {
    return null;
  }

  return (
    <Typography
      variant={isMobile ? "h6" : "h5"}
      sx={{
        fontFamily: "Roboto Mono, monospace",
        textAlign: "center",
        minWidth: "120px",
        color: (theme: Theme) => theme.palette.text.secondary,
      }}
    >
      Round: {state.currentRound}
    </Typography>
  );
});

RoundDisplay.displayName = "RoundDisplay";
-----------------

--- src/components/progress-indicator.tsx ---
import { Box, LinearProgress, Theme } from "@mui/material";
import { FC, memo, useMemo } from "react";

import { useTimerContext } from "../hooks/use-timer-context";

export const ProgressIndicator: FC = memo(() => {
  const { state } = useTimerContext();

  const progress = useMemo(
    () => Math.min((state.elapsedTime / state.targetTime) * 100, 100),
    [state.elapsedTime, state.targetTime],
  );

  const containerStyles = useMemo(() => ({ width: "100%", mt: 2 }), []);

  const progressBarStyles = useMemo(
    () => ({
      height: 8,
      borderRadius: 4,
      backgroundColor: (theme: Theme) =>
        theme.palette.grey[theme.palette.mode === "light" ? 200 : 800],
      "& .MuiLinearProgress-bar": {
        borderRadius: 4,
        backgroundColor: (theme: Theme) =>
          progress >= 100
            ? theme.palette.error.main
            : progress >= 80
              ? theme.palette.warning.main
              : theme.palette.primary.main,
        transition: "transform 0.1s linear",
      },
    }),
    [progress],
  );

  if (state.currentMode === "forTime" || !state.targetTime || !state.isRunning) {
    return null;
  }

  return (
    <Box sx={containerStyles}>
      <LinearProgress sx={progressBarStyles} value={progress} variant='determinate' />
    </Box>
  );
});

ProgressIndicator.displayName = "ProgressIndicator";
-----------------

--- src/components/time-input.tsx ---
import { Box, Chip, Stack, TextField, Theme } from "@mui/material";
import { ChangeEvent, FC, memo, useCallback } from "react";

import { TIME, TIMER_CONSTANTS } from "../constants/timer";
import { useTimerContext } from "../hooks/use-timer-context";

export const TimeInput: FC = memo(() => {
  const { state, currentTimer, setState } = useTimerContext();

  const handleChange = useCallback(
    (event: ChangeEvent<HTMLInputElement>) => {
      const value = event.target.value;
      const minutes = parseInt(value, 10);

      if (!isNaN(minutes)) {
        const targetTime = minutes * TIME.MILLISECONDS_IN_MINUTE;

        currentTimer.setTargetTime(targetTime);
        setState(currentTimer.getState());
      }
    },
    [currentTimer, setState],
  );

  const handleChipClick = useCallback(
    (minutes: number) => {
      const targetTime = minutes * TIME.MILLISECONDS_IN_MINUTE;

      currentTimer.setTargetTime(targetTime);
      setState(currentTimer.getState());
    },
    [currentTimer, setState],
  );

  if (state.currentMode === "forTime") {
    return null;
  }

  return (
    <Box sx={{ width: "100%" }}>
      <TextField
        fullWidth
        disabled={state.isRunning || state.countdownActive}
        label='Duration (minutes)'
        placeholder='Enter duration in minutes'
        size='small'
        type='number'
        value={state.targetTime ? state.targetTime / TIME.MILLISECONDS_IN_MINUTE : ""}
        slotProps={{
          htmlInput: {
            min: TIMER_CONSTANTS.MIN_MINUTES,
            max: TIMER_CONSTANTS.MAX_MINUTES,
            "aria-label": "Enter timer duration in minutes",
          },
        }}
        sx={{
          width: "100%",
          mb: 2,
          "& input": {
            textAlign: "center",
            fontFamily: "Roboto Mono, monospace",
            "&::-webkit-inner-spin-button, &::-webkit-outer-spin-button": {
              WebkitAppearance: "none",
              margin: 0,
            },
            "&[type=number]": {
              MozAppearance: "textfield",
            },
          },
        }}
        onChange={handleChange}
      />

      <Stack
        aria-label='Quick duration presets'
        direction='row'
        justifyContent='center'
        role='group'
        sx={{ mt: 1, flexWrap: "wrap", gap: 1 }}
      >
        {[5, 10, 15, 20].map((time) => (
          <Chip
            key={time}
            aria-label={`Set timer to ${time} minutes`}
            disabled={state.isRunning || state.countdownActive}
            label={`${time} min`}
            sx={{
              "&:hover": {
                backgroundColor: (theme: Theme) => theme.palette.primary.main,
                color: "white",
              },
            }}
            onClick={() => handleChipClick(time)}
          />
        ))}
      </Stack>
    </Box>
  );
});

TimeInput.displayName = "TimeInput";
-----------------

--- src/components/timer-display.tsx ---
import { Box, Fade, Theme, Typography, useMediaQuery } from "@mui/material";
import { FC, memo } from "react";

import { useTimerContext } from "../hooks/use-timer-context";
import { formatTimeLong } from "../utils/time";

export const TimerDisplay: FC = memo(() => {
  const isMobile = useMediaQuery((theme: Theme) => theme.breakpoints.down("sm"));
  const { state } = useTimerContext();

  return (
    <Box
      sx={{
        position: "relative",
        height: isMobile ? "6rem" : "8rem",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        fontFamily: "Roboto Mono, monospace",
      }}
    >
      {state.countdownActive ? (
        <Fade in={state.countdownActive}>
          <Typography
            variant={isMobile ? "h1" : "h1"}
            sx={{
              fontFamily: "inherit",
              fontVariantNumeric: "tabular-nums",
              position: "absolute",
              left: "50%",
              transform: "translateX(-50%)",
              color: "inherit",
              fontSize: isMobile ? "4rem" : "6rem",
            }}
          >
            {state.countdownValue}
          </Typography>
        </Fade>
      ) : (
        <Typography
          variant={isMobile ? "h2" : "h1"}
          sx={{
            fontFamily: "inherit",
            fontVariantNumeric: "tabular-nums",
            fontSize: isMobile ? "2rem" : "4rem",
          }}
        >
          {formatTimeLong(
            state.currentMode === "forTime"
              ? state.elapsedTime
              : Math.max(0, state.targetTime - state.elapsedTime),
          )}
        </Typography>
      )}
    </Box>
  );
});

TimerDisplay.displayName = "TimerDisplay";
-----------------

--- src/components/control-buttons.tsx ---
import PlayArrow from "@mui/icons-material/PlayArrow";
import Refresh from "@mui/icons-material/Refresh";
import Stop from "@mui/icons-material/Stop";
import { Button, ButtonGroup } from "@mui/material";
import { FC, memo, useCallback } from "react";

import { useTimer } from "../hooks/use-timer";

export const ControlButtons: FC = memo(() => {
  const { state, startTimer, stopTimer, resetTimer } = useTimer();

  const isStartDisabled =
    (state.currentMode !== "forTime" && !state.targetTime) ||
    state.isRunning ||
    state.countdownActive;

  const handleStart = useCallback(() => {
    if (state.currentMode === "forTime") {
      startTimer();
    } else if (state.targetTime > 0) {
      startTimer(state.targetTime);
    }
  }, [state.currentMode, state.targetTime, startTimer]);

  const handleStop = useCallback(stopTimer, [stopTimer]);
  const handleReset = useCallback(resetTimer, [resetTimer]);

  return (
    <ButtonGroup
      disableElevation
      aria-label='Timer controls'
      orientation='horizontal'
      role='group'
      variant='contained'
      sx={{
        width: "100%",
        "& .MuiButton-root": {
          width: "100%",
          borderRight: "none",
        },
        "& .MuiButtonGroup-grouped:not(:last-of-type)": {
          borderRight: "none",
        },
      }}
    >
      <Button
        aria-label={`Start ${state.currentMode} timer`}
        color='success'
        disabled={isStartDisabled}
        startIcon={<PlayArrow />}
        onClick={handleStart}
      >
        Start
      </Button>

      <Button
        aria-label='Stop timer'
        color='error'
        disabled={!state.isRunning}
        startIcon={<Stop />}
        onClick={handleStop}
      >
        Stop
      </Button>

      <Button
        aria-label='Reset timer'
        color='warning'
        disabled={state.countdownActive}
        startIcon={<Refresh />}
        onClick={handleReset}
      >
        Reset
      </Button>
    </ButtonGroup>
  );
});

ControlButtons.displayName = "ControlButtons";
-----------------

--- src/components/time-display.tsx ---
import { Box, Theme, Typography, useTheme } from "@mui/material";
import { FC, memo, useMemo } from "react";

import { useTimerContext } from "../hooks/use-timer-context";
import { formatTimeShort } from "../utils/time";

export const TimeDisplay: FC = memo(() => {
  const theme = useTheme<Theme>();
  const { state } = useTimerContext();

  const time = state.countdownActive ? state.countdownValue : state.elapsedTime;
  const formattedTime = useMemo(() => formatTimeShort(time), [time]);

  const textColor = useMemo(() => {
    if (state.countdownActive) {
      return theme.palette.warning.main;
    }

    return theme.palette.text.primary;
  }, [state.countdownActive, theme.palette]);

  const containerStyles = useMemo(() => ({ textAlign: "center", width: "100%" }), []);
  const timeStyles = useMemo(() => ({ fontWeight: "bold", color: textColor }), [textColor]);

  return (
    <Box aria-live='polite' role='timer' sx={containerStyles}>
      {state.currentMode === "emom" && state.isRunning && (
        <Typography
          gutterBottom
          aria-label={`Round ${state.currentRound}`}
          color='text.secondary'
          variant='h6'
        >
          Round {state.currentRound}
        </Typography>
      )}

      <Typography
        aria-label={`${state.countdownActive ? "Countdown" : state.currentMode} timer: ${formattedTime}`}
        component='div'
        sx={timeStyles}
        variant='h2'
      >
        {formattedTime}
      </Typography>

      {state.countdownActive && state.countdownDuration > 0 && (
        <Typography aria-label='Get ready for workout' color='text.secondary' variant='subtitle1'>
          Get ready!
        </Typography>
      )}
    </Box>
  );
});

TimeDisplay.displayName = "TimeDisplay";
-----------------

--- src/components/countdown-settings.tsx ---
import { Box, Slider, Theme, Typography, useMediaQuery, useTheme } from "@mui/material";
import { FC, memo, useCallback } from "react";

import { TIMER_CONSTANTS } from "../constants/timer";
import { useTimerContext } from "../hooks/use-timer-context";

export const CountdownSettings: FC = memo(() => {
  const theme = useTheme<Theme>();
  const isMobile = useMediaQuery(theme.breakpoints.down("sm"));

  const { state, currentTimer, setState } = useTimerContext();

  const handleChange = useCallback(
    (_: Event, value: number | number[]) => {
      if (typeof value === "number") {
        currentTimer.setCountdownDuration(value);
        setState(currentTimer.getState());
      }
    },
    [currentTimer, setState],
  );

  return (
    <Box sx={{ width: "100%", mt: isMobile ? 2 : 4, px: isMobile ? 0 : 2 }}>
      <Typography gutterBottom align={isMobile ? "center" : "left"}>
        Countdown Duration: {state.countdownDuration / 1000}s
      </Typography>

      <Slider
        disabled={state.isRunning || state.countdownActive}
        max={TIMER_CONSTANTS.MAX_COUNTDOWN}
        min={TIMER_CONSTANTS.MIN_COUNTDOWN}
        step={1000}
        value={state.countdownDuration}
        valueLabelDisplay='auto'
        valueLabelFormat={(value) => `${value / 1000}s`}
        marks={[
          { value: 0, label: "0s" },
          { value: 3000, label: "3s" },
          { value: 5000, label: "5s" },
          { value: 10000, label: "10s" },
        ]}
        sx={{
          "& .MuiSlider-markLabel": {
            fontSize: isMobile ? "0.75rem" : "0.875rem",
          },
        }}
        onChange={handleChange}
      />
    </Box>
  );
});

CountdownSettings.displayName = "CountdownSettings";
-----------------

--- src/main.tsx ---
import React from "react";
import ReactDOM from "react-dom/client";

import App from "./App";

ReactDOM.createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
);
-----------------

--- src/services/sound.service.ts ---
class SoundService {
  private audioContext: AudioContext | null = null;
  private lastPlayTime = 0;
  private readonly MIN_INTERVAL = 1000;
  private isInitialized = false;

  async initialize(): Promise<void> {
    if (!this.isInitialized) {
      try {
        const AudioContext = window.AudioContext || (window as any).webkitAudioContext;

        this.audioContext = new AudioContext();

        if (this.audioContext.state === "suspended") {
          await this.audioContext.resume();
        }

        this.isInitialized = true;
      } catch (error) {
        console.error("Failed to initialize audio context:", error);
      }
    }
  }

  private async getAudioContext(): Promise<AudioContext | null> {
    if (!this.audioContext || this.audioContext.state === "suspended") {
      await this.initialize();
    }

    return this.audioContext;
  }

  private async createBeep(frequency: number, duration: number): Promise<void> {
    const ctx = await this.getAudioContext();

    if (!ctx) {
      return;
    }

    const oscillator = ctx.createOscillator();
    const gainNode = ctx.createGain();

    oscillator.connect(gainNode);
    gainNode.connect(ctx.destination);

    oscillator.type = "sine";
    oscillator.frequency.value = frequency;
    gainNode.gain.value = 0.1;

    gainNode.gain.setValueAtTime(0.1, ctx.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration);

    oscillator.start(ctx.currentTime);
    oscillator.stop(ctx.currentTime + duration);
  }

  async playSound(type: "shortBeep" | "longBeep"): Promise<void> {
    const now = Date.now();

    if (now - this.lastPlayTime < this.MIN_INTERVAL) {
      return;
    }

    try {
      if (this.audioContext?.state === "suspended") {
        this.isInitialized = false;
        await this.initialize();
      }

      if (type === "shortBeep") {
        await this.createBeep(880, 0.1);
      } else {
        await this.createBeep(440, 0.6);
      }

      this.lastPlayTime = now;
    } catch (error) {
      console.error("Failed to play sound:", error);
    }
  }

  async playCountdownSound(secondsLeft: number): Promise<void> {
    const seconds = Math.floor(secondsLeft);

    if (seconds === 2 || seconds === 1 || seconds === 0) {
      await this.playSound("shortBeep");
    }
  }

  async playStartSound(): Promise<void> {
    await this.playSound("longBeep");
  }

  async playEmomSound(timeInMinute: number): Promise<void> {
    const seconds = Math.floor(timeInMinute / 1000);

    if (seconds >= 57 && seconds <= 59) {
      await this.playSound("shortBeep");
    } else if (timeInMinute < 1000) {
      await this.playSound("longBeep");
    }
  }
}

export const soundService = new SoundService();
-----------------

--- src/services/audio.service.ts ---
import { soundService } from "./sound.service";

export class AudioService {
  initialize() {
    soundService.initialize();
  }

  playCountdown(seconds: number) {
    soundService.playCountdownSound(seconds);
  }

  playStart() {
    soundService.playStartSound();
  }

  playEmom(timeInMinute: number) {
    soundService.playEmomSound(timeInMinute);
  }
}

export const audioService = new AudioService();
-----------------

--- src/services/timer.service.ts ---
import { BaseTimer } from "../models/base-timer";
import { TimerFactory } from "../models/timer-factory";
import { TimerMode } from "../types/timer";

import { audioService } from "./audio.service";
import { soundManager } from "./sound-manager";

export class TimerService {
  private timer: BaseTimer;

  constructor(mode: TimerMode) {
    this.timer = TimerFactory.createTimer(mode);
  }

  getTimer(): BaseTimer {
    return this.timer;
  }

  getState() {
    return this.timer.getState();
  }

  setMode(mode: TimerMode) {
    this.timer = TimerFactory.createTimer(mode);
  }

  start(targetTime?: number) {
    if (!this.timer.canStart()) {
      return;
    }

    this.timer.start(targetTime);
    audioService.initialize();

    if (!this.timer.getState().countdownActive) {
      soundManager.update(this.timer.getState());
    }
  }

  stop() {
    this.timer.stop();
  }

  reset() {
    this.timer.reset();
  }

  setCountdownDuration(duration: number) {
    this.timer.setCountdownDuration(duration);
  }

  setTargetTime(time: number) {
    this.timer.setTargetTime(time);
  }

  update() {
    this.timer.update();
    soundManager.update(this.timer.getState());
  }
}
-----------------

--- src/services/sound-manager.ts ---
import { TIME, TIMER_CONSTANTS } from "../constants/timer";
import { TimerState } from "../models/base-timer";

import { audioService } from "./audio.service";

export class SoundManager {
  playCountdown(state: TimerState) {
    if (state.countdownActive) {
      const seconds = Math.floor(state.countdownValue / TIME.MILLISECONDS_IN_SECOND);

      audioService.playCountdown(seconds);
    }
  }

  playStart(state: TimerState) {
    if (state.isRunning && state.elapsedTime < TIMER_CONSTANTS.START_SOUND_THRESHOLD) {
      audioService.playStart();
    }
  }

  playEmom(state: TimerState) {
    if (state.currentMode === "emom" && state.isRunning) {
      const timeInMinute = state.elapsedTime % TIME.MILLISECONDS_IN_MINUTE;

      audioService.playEmom(timeInMinute);
    }
  }

  update(state: TimerState) {
    this.playCountdown(state);
    this.playStart(state);
    this.playEmom(state);
  }
}

export const soundManager = new SoundManager();
-----------------

--- src/theme/breakpoints.ts ---
export const breakpoints = {
  values: {
    xs: 0,
    sm: 600,
    md: 900,
    lg: 1200,
    xl: 1536,
  },
} as const;

export const deviceSizes = {
  mobile: `(max-width: ${breakpoints.values.sm - 1}px)`,
  tablet: `(min-width: ${breakpoints.values.sm}px) and (max-width: ${breakpoints.values.md - 1}px)`,
  desktop: `(min-width: ${breakpoints.values.md}px)`,
} as const;
-----------------

--- src/theme/theme.ts ---
import { createTheme, responsiveFontSizes } from "@mui/material";

import { breakpoints } from "./breakpoints";

export const createAppTheme = (mode: "light" | "dark") => {
  const theme = createTheme({
    breakpoints,
    palette: {
      mode,
    },
    typography: {
      fontFamily: "'Roboto Mono', monospace",
      h2: {
        fontSize: "3rem",
        "@media (min-width:600px)": {
          fontSize: "3.75rem",
        },
        "@media (min-width:900px)": {
          fontSize: "4.5rem",
        },
      },
      h6: {
        fontSize: "1.1rem",
        "@media (min-width:600px)": {
          fontSize: "1.25rem",
        },
      },
    },
    components: {
      MuiContainer: {
        styleOverrides: {
          root: {
            "@media (min-width:600px)": {
              paddingLeft: "2rem",
              paddingRight: "2rem",
            },
          },
        },
      },
      MuiButtonGroup: {
        styleOverrides: {
          root: {
            gap: 20,
          },
        },
      },
      MuiButton: {
        styleOverrides: {
          root: {
            textTransform: "none",
            borderRadius: 8,
          },
        },
      },
    },
  });

  return responsiveFontSizes(theme);
};
-----------------

--- src/utils/time.ts ---
export const formatTimeLong = (ms: number): string => {
  const hours = String(Math.floor(ms / 3600000)).padStart(2, "0");
  const minutes = String(Math.floor((ms % 3600000) / 60000)).padStart(2, "0");
  const seconds = String(Math.floor((ms % 60000) / 1000)).padStart(2, "0");
  const milliseconds = String(Math.floor((ms % 1000) / 10)).padStart(2, "0");

  return `${hours}:${minutes}:${seconds}:${milliseconds}`;
};

export const formatTimeShort = (ms: number): string => {
  const totalSeconds = Math.floor(ms / 1000);
  const hours = Math.floor(totalSeconds / 3600);
  const minutes = Math.floor((totalSeconds % 3600) / 60);
  const seconds = totalSeconds % 60;
  const milliseconds = Math.floor((ms % 1000) / 10);
  const pad = (num: number, size: number = 2) => num.toString().padStart(size, "0");

  return `${hours ? `${pad(hours)}:` : ""}${pad(minutes)}:${pad(seconds)}:${pad(milliseconds)}`;
};
-----------------

--- src/setupTests.ts ---
import "@testing-library/jest-dom";
-----------------

--- src/constants/timer.ts ---
export const TIME = {
  MILLISECONDS_IN_SECOND: 1000,
  MILLISECONDS_IN_MINUTE: 60000,
  MILLISECONDS_IN_HOUR: 3600000,
  SECONDS_IN_MINUTE: 60,
  MINUTES_IN_HOUR: 60,
} as const;

export const TIMER_CONSTANTS = {
  MIN_MINUTES: 1,
  MAX_MINUTES: 60,
  DEFAULT_COUNTDOWN: 3000,
  MIN_COUNTDOWN: 0,
  MAX_COUNTDOWN: 10000,
  UPDATE_INTERVAL: 10,
  COUNTDOWN_INTERVAL: 1000,
  EMOM_WARNING_TIME: 50000,
  EMOM_DANGER_TIME: 55000,
  START_SOUND_THRESHOLD: 100,
} as const;

export const STORAGE_KEYS = {
  LAST_MODE: "lastMode",
  THEME: "theme",
  COUNTDOWN_DURATION: "countdownDuration",
} as const;

export const SOUNDS = {
  COUNTDOWN: "countdown",
  GO: "go",
  ROUND: "round",
  FINISH: "finish",
} as const;
-----------------

--- src/App.tsx ---
import { CssBaseline, ThemeProvider } from "@mui/material";
import { FC, useMemo } from "react";

import { Timer } from "./components/timer";
import { TimerProvider } from "./context/timer-provider";
import { useTimerContext } from "./hooks/use-timer-context";
import { createAppTheme } from "./theme/theme";

const TimerApp: FC = () => {
  const { state } = useTimerContext();
  const theme = useMemo(() => createAppTheme(state.theme), [state.theme]);

  return (
    <ThemeProvider theme={theme}>
      <CssBaseline />
      <Timer />
    </ThemeProvider>
  );
};

const App: FC = () => {
  return (
    <TimerProvider>
      <TimerApp />
    </TimerProvider>
  );
};

export default App;
-----------------
